---
alias: Cargo
tags:
  - rust
  - language
---

**Cargo** - это система сборки и менеджер пакетов для [[Rust]]. Большинство проектов на *Rust* используют *Cargo* для управления зависимостями и сборки.

Простейшие программы на *Rust*, не имеют дополнительных зависимостей и в этом случае проект сборка может осуществляться и без участия *Cargo*, однако как правило проекты имеют свойство усложняться и обрастать зависимостями, поэтому даже самый простой проект смело можно создавать используя *Cargo*, поскольку последующее добавление зависимостей с ним будет намного проще.

Чтобы убедиться в наличии Cargo в системе достаточно проверить его версию:

```Zsh
$ cargo --version
```

Если *Rust* был установлен через `rustup`, то *Cargo* также будет доступен в системе.

## Создание проекта с Cargo

Создадим `Hello world!` проект с *Cargo* и посмотрим чем он отличается от проекта созданного вручную.

```Zsh
$ cargo new hello_cargo
$ cd hello_cargo
```

После успешного выполнения команды *Cargo* создаст директорию с соответствующим проекту названием.

Перейдя в директорию, проверим список созданных файлов.

```Zsh
$ ls
Cargo.toml src
```

Вместе с `Cargo.toml` и `main.rs`, *Cargo* также по умолчании инициализирует *git* репозиторий и соответствующий ему `.gitignore` файл.

> Изменить систему контроля версий по умолчанию можно использовав флаг `--vcs`, например `cargo new --vcs=git <project_name>`.

Рассмотрим содержимое `Cargo.toml`:

```Toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

Секция `package` содержит информацию о программе, как о пакете:

- **name** — название программы;
- **version** — версия программы;
- **edition** — версия *Rust* необходимая для запуска программы.

Секция `dependencies` содержит список зависимостей проекта. По умолчанию проект на `Rust` не имеет сторонних зависимостей.

Перейдём к содержимому директории `src`, в ней находится точка входа в проект `main.rs`, рассмотрим этот файл:

```Rust
fn main() {
    println!("Hello, world!");
}
```

Каждый новый проект Cargo представляет собой `Hello world!` и может быть запущен сразу, "из коробки".

*Cargo* предполагает наличие определённой структуры проекта — все файлы с исходным кодом следует держать в директории `src`. Корневой каталог проекта предназначен только для файлов README, лицензионной информации, файлов конфигурации и всего, что не связано с вашим кодом. 

Использование *Cargo* в проекте помогает в организации структуры проекта и позволяет быть уверенным, что все его компоненты находятся на своих местах.

В случае если мы уже имеем на руках проект на *Rust*, не использующий *Cargo*,  мы можем очень просто добавить *Cargo* в проект, для этого достаточно поместить `.rs` файлы в директорию `src`, а также создать в корне соответствующий `Cargo.toml` файл.

## Сборка и запуск проекта с Cargo

Теперь рассмотрим отличие процессов сборки проекта с *Cargo* и без него.

Запустим сборку с *Cargo*:

```Zsh
$ cargo build
   Compiling hello_cargo v0.1.0 (/Users/antonpetrov/Rust/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 8.50s
```

Данная команда создаст исполняемый файл `hello_cargo` внутри директории `target/debug`, где также будут находиться прочие артефакты сборки.

Запустим исполняемый файл `hello_cargo`:

```Zsh
$ target/debug/hello_cargo
Hello, world!
```

Вместе с тем в корневой директории будет создан файл `Cargo.lock`, в котором будет храниться история зависимостей проекта. 

Библиотеки  *Rust* создаются и поддерживаются сообществом, кто угодно и когда угодно может создать собственную библиотеку, что возможно станет популярной и станет фигурировать в зависимостях проектов других разработчиков.

Для того чтобы проекты на *Rust* не ломались из-за ошибок совместимости разных библиотек, *Cargo* обновляет дерево зависимостей при каждом добавлении новых или обновлении существующих зависимостей, а история всех подобных имений хранится в файле `Cargo.lock`, и практически никогда, не изменяется вручную.

Для запуска скомпилированной программы мы использовали её имя включая путь от корня проекта, однако мы также можем использовать команду `cargo run`, которая скомпилирует код программы и сразу запустит его:

```Zsh
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running `target/debug/hello_cargo`
Hello, world!
```

Поскольку *Cargo* предполагает наличие определённой структуры проекта, запуск программы через команду `cargo run` избавляет нас от необходимости вручную обращаться к исполняемому файлу по имени.

Также заметим, что в случае второго запуска программы через `cargo run` шаг компиляции отсутствовал. Дело в том, что процесс компиляции достаточно дорогая операция как с точки зрения времени, так и с точки зрения нагрузки, и когда *Cargo* не обнаружил изменений в исходном коде программы на втором запуске, он просто пропустил шаг компиляции и сразу перешёл к её выполнению. 

*Cargo* также предоставляет команду `cargo check`, что быстро проверяет код программы в процессе компиляции, но не создаёт исполняемый файл.

```Zsh
$ cargo check
    Checking hello_cargo v0.1.0 (/Users/antonpetrov/Rust/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.60s
```

Зачастую команду `cargo check` используют в процессе отладки программ, поскольку без генерации исполняемого файла процесс компиляции происходит намного быстрее.

## Сборка релизной версии программы

Когда проект на *Rust* готов, как правило, разработчики собирают его оптимизированную версию с командой `cargo build --release`. В отличии от обычной сборки, оптимизированная выполняется намного дольше, но исполняемый файл при этом работает намного быстрее.

Также оптимизированная (релизная) сборка программы будет помещена в директорию `target/release` вместо `target/debug`.

Релизная сборка программы предназначена для конечных пользователей, не предполагает последующей отладки и работает на сколько это возможно быстро.

## Список источников

- [Hello, Cargo! (Rust book)](https://doc.rust-lang.org/book/ch01-03-hello-cargo.html)