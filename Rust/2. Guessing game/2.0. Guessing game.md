---
tags:
 - rust
 - language
 - tutorial
---

Теперь прыгнем немного вперёд и разберём некоторые базовые концептами [[Rust]]. Познакомимся с `let` и `match`, методами, ассоциативными функциями, отдельными пакетами (*crates*) и многим другим.

Рассмотрим классическую учебную задачу **Guessing game** ( игру "Угадай число"):

Программа генерирует случайное число от 1 до 100 и предоставляет пользователю интерфейс вводе, где он может попробовать угадать загаданное число. В случае если число больше загаданного программа должна вывести соответствующее сообщение, если введённое число меньше, сообщение также должно быть соответствующим. Игра продолжается до тех пор пока пользователь не угадает загаданное число. Также следует учесть случаи не валидного ввода и обрабатывать их соответствующим образом.

## Создадим проект "Guessing game"

Для создания проекта воспользуемся уже знакомой нам утилитой `cargo` и перейдём в созданную директорию проекта.

```Zsh
$ cargo new guessing_game
$ cd guessing_game
```

Cargo создаст для нас стандартную **Hello, world!** программу, которую мы уже можем изменять по нашему усмотрению.

## Обработка пользовательского ввода

Сперва пригласим пользователя ко вводу, выведим соответствующее  сообщение на экран, после чего будем ждать пользовательского ввода и сохраним его в переменную.

```Rust
use std::io;

fn main() {
    println!("Guess the number!");

    println!("Please input your guess.");

    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess)
        .expect("Failed to read line");

    println!("You guessed: {guess}");
}
```

Для обработки пользовательского ввода нам понадобится добавить библиотеке `io` в проект. Библиотека `io` входит в состав стандартной библиотеки `std`.

*Rust* из коробки предоставляет набор компонентов стандартной библиотеки, которые он добавляет в область видимости каждой программы. Набор таких функций называется [[prelude]].

Если тип или функция, что мы хотим использовать не входят в `prelude`, то нам нужно явно добавить их в проект, используя ключевое слово `use`. Выражение `use std::io` добавляет в программу ряд связанных функций, включая обработку пользовательского ввода.

### Хранение пользовательского ввода

Для хранения пользовательского ввода мы определили мутабельную (изменяемую) переменную `guess`. 

```Rust
let mut guess = String::new();
```

Рассмотрим ещё несколько примеров определения переменных.

```Rust
let apples = 5;
```

В данном случае мы определили неизменяемую переменную `apples` и поместили внутрь целочисленное значение `5`. По умолчанию в *Rust* все переменные иммутабельны, то есть единожды заданное значение переменной не может быть изменено. Для того чтобы сделать переменную изменяемой мы добавляем ключевое слово `mut` при объявлении переменной.

```Rust
let apples = 5; // immutable
let mut bananas = 5; // mutable
```

В нашем случае переменной `guess` мы присваиваем значение `String::new()`, где `String` — это строковый тип данных, а `new` — функция, что возвращает пустую строку. В целом функция `new` является стандартной для многих типов данных, это своеобразный конструктор, что возвращает пустой экземпляр, соответствующего типа.

Синтаксис `::` указывает, что `new` является ассоциативной функцией типа `String`. **Ассоциативная функция** — это функция определённая на уровне типа.

### Захват пользовательского ввода

В самом начале программы мы добавили библиотеку `std::io` в проект. Теперь для захвата пользовательского ввода мы используем функцию `stdin` из библиотеки `io`.

```Rust
    io::stdin()
        .read_line(&mut guess)
```

В случае если библиотека `io` не была добавлена в программу заранее, мы всё ещё можем использовать её функции по их полному имени, включая имя библиотеки — `std::io::stdin`.

Ассоциативная функция `io::stdin` возвращает экземпляр объекта `std::io::Stdin`, что представляет из себя объект-обработчик стандартного вывода в терминал.

В следующей строке мы используем метод `.read_line(&mut guess)`, что принимает в качестве аргумента строку, куда будет помещён пользовательский ввод.

В нашем случае мы поредаём в качестве аргумента референс `&` на переменную `guess`. **Референсы** в *Rust* представляют собой своеобразные ссылки на переменные, что позволяет нам в программе многократно использовать одни и те же переменные без необходимости дублировать данные в памяти несколько раз.

Референсы — это весьма комплексный концепт и основное преимущество *Rust* состоит как раз в том, как просто и безопасно он позволяет работать с этой концепцией.

Также следует заметить, что референсы в *Rust*, как и переменные, по умолчанию иммутабельны, поэтому, чтобы присвоить значение ввода референсу `guess` нам необходимо явно указать на его мутабельность: `&mut guess`.

### Обработка потенциальных ошибок

Перейдём к следующему методу обработки пользователского ввода:

```Rust
        .expect("Failed to read line");
```

Следует заметить, что с точки зрения *Rust* мы последовательно обрабатываем вызовы объекта `std::io::Stdin`, не смотря на то что мы разделили их обработку на несколько строк. В данном случае запись логически эквивалентна вызову всех методов в цепочке в одной строке и данное разделение служит исключительно наглядности кода.

```Rust
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

> Аналогичный тип записи также приемлем в *Python* и *JavaScript*.

Как было упомянуто ранее метод `read_line` помещает значение пользователского ввода в переданную в аргументе переменную, однако метода также возвращает экземпляр объекта `Result`. **Result** — это `Enum`, объект часто представляющий собой набор состояний, называемых **вариантами**.

Варианты результата `read_line` — `Ok` и `Err`. `Ok` сигнализирует об успешном завершении выполнения метода, `Err` означает, что выполнение завершилось с ошибкой.

Как и большинство других объектов, `Result` имеет перечень определённых для него методов. В нашем случае у экземпляра объекта `Rusult` мы используем вызываем `expect`, что выведет в терминал сообщение, если метод `read_line` вернёт `Err`, если `read_line` вернёт `Ok`, вызов метода `expect` просто вернёт количество байт в пользовательском вводе.

Мы можем игнорировать обработку потенциальных ошибок, но в этом случае мы получим предупреждение в процессе компиляции.

```Zsh
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
  --> src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` on by default

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
```

Лучшей практикой считается вывод информации об ошибке, что привела к падению программы, но в нашем случае вывод более скромного сообщения будет достаточно.

### Вывод с println! плейсхолдерами

Подробнее рассмотрим конструкцию:

```Rust
    println!("You guessed: {guess}");
```

В данном случае в терминал будет выведено сообщение, содержащее пользовательский ввод. Фигурные скобки `{}` внутри строки определяют **прейсхолдер** — место куда в процессе выполнения программы будет подставлено значение из одноимённой переменной. 

Для вывода результата выражения следует использовать пустой плейсхолдер, а затем после этой строки, через запятую следует перечислить выражения, результаты которых будут помещены в строку по принципу: один плейсхолдер — одно выражение.

Также следует заметить, что *Rust* допускает комбинации пустых плейсхолдеров и плейсхолдеров с переменными, например:

```Rust
let x = 5;
let y = 10;

println!("x = {x} and y + 2 = {}", y + 2);
```

Результатом данного выражения станет строка `x = 5 and y + 2 = 12`.

> Порядок пустых плейсхолдеров и плейсхолдеров с переменными в строке может быть любым, однако количество плейсхолдеров в строке и переменных и выражений должны соответствовать друг другу.

### Проверка первой части программы

Запустим программу с помощью `cargo run`:

```Zsh
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

На этом первую часть игры можно считать готовой: мы захватываем ввод пользователя с клавиатуры, помещаем его в переменную и выводим значение этой переменной в терминал.

