---
tags:
  - rust
  - language
  - tutorial
---

Теперь, когда мы имеем локально установленный *Rust*, время создать нашу первую программу на этом языке. Традиционно знакомство с языками программирования начинается с написания программы **Hello, world!**,чем мы и займёмся.

Сперва создадим директорию проекта `hello_world`:

```Zsh
$ mkdir hello_world
$ cd hello_world
```

Затем создадим точку входа в проект `main.rs` и определим внутри функцию `main`:

```Rust
fn main() {
    println!("Hello, World!");
}
```

> В данном случае файл `main.rs` состоит из одного слова, однако если бы слов в названии файла было несколько, например `hello world`, то следуя соглашению об именовании в *Rust* нам следовало бы назвать файл `hello_world.rs`. Каждый *Rust* файл предполагает наличие расширения `.rs` в конце.

Запустим процесс компиляции решения и затем запустим проект:

```Zsh
$ rustc main.rs
$ ./main
Hello, World!
```

## Программные компоненты

```Rust
fn main() {

}
```

Здесь мы определили функцию `main`. Функция `main` в контексте программ на *Rust* — это своего рода точка входа в программу. Эта функция всегда выполняется самой первой при запуске.

В данном случае функция `main` не принимает ни каких аргументов, однако если бы она их принимала, то нам следовало бы определить их внутри круглых скобок `()`.

Тело функции определяется внутри фигурных скобок `{}`, как правило открывающая скобка находится на той же строке, где объявляется функция и отделяется от списка аргументов одним пробелом.

> Для соблюдения более однообразного code style для различных языков предусмотрены соответствующие форматтеры, *Rust* не стал исключением и в включает в состав свой стандартной поставки утилиту `rustfmt`, она устанавливается вместе с остальными компонентами *Rust toolchain* и доступна из коробки.

```Rust
    println!("Hello, World!");
```

В теле функции `main` мы выводим на экран строку `Hello, World!`, и здесь есть пара занимательных деталей:

- Code style *Rust* предполагает использовать в качестве отступа 4 пробела (вместо знака табуляции);
- `println!` — это **макрос** *Rust*. В целом если вместо макроса нам необходимо использовать функцию мы можем это сделать заменив ей вызов макроса `println` (без `!` в конце имени);
- `"Hello, World!"` — это строка, макрос `println!` принимает строку и выводит её на экран;
- В конце строки мы указываем символ `;`, Таким образом мы говорим компилятору *Rust*, что выражение завешено и он может переходит ко следующей части программы.

## Компиляция и запуск

Прежде чем мы сможем запустить программу на *Rust* нам необходимо скомпилировать её:

```Zsh
$ rustc main.rs
```

> Компиляция программы на *Rust* схожа с компиляцией на *C через утилиты  `gcc` и `clang`.

После завершения компиляции в директории с исходным кодом программы появится исполняемый файл:

```Zsh
$ ls
main main.rs
```

Запустив исполняемый файл мы запустим код соответствующей ему программы:

```Zsh
$ ./main
Hello, World!
```

В динамических языкая, таких как *Python, Ruby* или *JavaScript*, шаг компиляции и запуска, как правило, не являются явно отдельными друг процессами. *Rust* в свою очень  **ahead-of-time compiled** (компилируемый до выполнения) язык, что позволяет запускать программы на *Rust* даже на машинах, где компилятор *Rust* отсутствует. 

С другой стороны для запуска программ на динамических языках требует от пользователя только наличия кода программы и компилятора  / интерпретатора языка на машине пользователя, последующая компиляция не требуется. Каждый из подходов имеет свои преимущества и недостатки и подход в *Rust* не хуже и не лучше всех прочих, он просто отличается.

Компиляция с `rustc` подходит скорее для простых программ, для проектов с более сложной структурой нам определённо понадобится более продвинутый инструмент надгробии `npm` для *JavaScript* или `poetry` для *Python*. К счастью, для *Rust*  существует свой *package management tool* — `cargo`, который используется в большинстве production решений на *Rust*.

## Список источников

- [Hello, World! (Rust book)](https://doc.rust-lang.org/book/ch01-02-hello-world.html)